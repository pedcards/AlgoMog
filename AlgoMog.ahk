/*	ALGAE transmogrifier, (C) TC 2013-2014
	Tool for converting XML files into $elem() array blocks for use in ALGAE
	scripts.
	ALGAE = Algorithm Logic Graphical Application Encoder
	
    Ver 1.1 (1/11/14) - Draw.io now exports mxGraph XML files, which have more metadata than before. Need to use real XML parsing. Using the xml.ahk script discussed here: http://www.autohotkey.com/board/topic/89197-xml-build-parse-xml/
    The Draw.io mxGraph XML format is not clean. The outer node <mxGraphModel></mxGraphModel> breaks the XML parser and should be removed first. Although this does not seem consistent.
	Ver 1.2 (1/19/14) - Reads XML file and parses properly. Compresses nodes sequentially. Next step is to add behavior for terminators? Need to modify ALGAE code to read XML instead of $elem() array blocks?
*/

#Include xml.ahk
#NoEnv  ; Recommended for performance and compatibility with future AutoHotkey releases.
SendMode Input  ; Recommended for new scripts due to its superior speed and reliability.

/* Get the XML file generated by http://draw.io 
*/
FileSelectFile, filename,,, Select XML file:, *.xml
FileRead, xfile, %filename%

x := new XML(xfile)				; XML file in
y := new XML("<root/>")			; XML file output

/*
Put elements into new XML file:
    <elem id="1" parent="0">                <== parent is for going back
      <display>blah blah blah</display>
      <option target="2">Yes</option>       <== connectors, added in order of appearance 
      <option target="3">No</option>            in XML file when source = id
      <option target="6">Maybe</option>
    </elem>
*/
Loop, % (mxC:=x.selectNodes("//mxCell")).length {	; Number of nodes
	k := mxC.item((i:=A_Index)-1)					; Get next node from X
	mxID := k.getAttribute("id")
	mxParent := k.getAttribute("parent")
    mxValue := k.getAttribute("value")
	mxValue := RegExReplace(mxValue, "<[^>]+>" , "")	; Strip out HTML tags http://www.autohotkey.com/board/topic/10707-fastest-way-to-remove-html-tags/?p=89378
	mxStyle := k.getAttribute("style")
	mxSource := k.getAttribute("source")
	mxTarget := k.getAttribute("target")

	IfInString, mxStyle, shape		; Any non-connector shape will do
	{
		y.addElement("elem", "root", {id: mxID})		; Create new node in Y
		y.addElement("display", "//elem[@id='" mxID "']", mxValue)		; Create element <display> with text field
	}
  
	IfInString, mxStyle, endArrow		; denotes a connector
	{
		if ((mxSource = "") or (mxTarget = "")) {		; If connector has either no valid source or target 
			linerr := mxSource . mxTarget				; Concat string of source and target (one or both will be "")
			boxerr := y.SelectSingleNode("//elem[@id='" mxSource "']").text		; Get the elem text for the Source and Target
			MsgBox , , Diagram ERROR, % "Broken link at`nNode: " mxSource . mxTarget "`n`n" boxerr
		} else {
			y.addElement("option", "//elem[@id='" mxSource "']", {target: mxTarget}, mxValue)
		}
	}
}
y.viewXML()

/*
	Traverse each node. For each Elem, reindex sequentially.
	Traverse all //elem/option elements (links). Replace references to the oldID with the newID. 
*/
Loop, % (elemnode:=y.selectNodes("//elem")).length {
	k := elemnode.item((i:=A_Index)-1)
	k1 := k.getAttribute("id")
	k.setAttribute("id", i)
	Loop, % (elemelems:=y.selectNodes("//elem/option")).length {
		kk := elemelems.item((j:=A_Index)-1)
		If (kk.getAttribute("target") = k1) {
			kk.setAttribute("target", i)
		}
	}
}
y.viewXML()

ExitApp
